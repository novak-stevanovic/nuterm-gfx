#include <assert.h>
#include <math.h>

#include "object/ntg_label.h"
#include "object/_ntg_label.h"
#include "object/shared/ntg_object_drawing.h"
#include "shared/_ntg_shared.h"
#include "shared/ntg_string.h"

/* content_len - length of text inside row(excluding padding)
 * 
 * If `content_len` + `indent` > `row_total_len`, the text will be clipped.
 *
 * Function assumes that `content_len` <= `row_total_len`,
 * `indent` <= `row_total_len`,
 * `row` is not NULL */
static void __row_apply_alignment_and_indent(uint32_t* row, size_t indent,
        size_t content_len, size_t row_total_len, ntg_text_alignment alignment);

static void __arrange_label_content_nowrap(const ntg_label_rows_utf32* rows,
        size_t indent, ntg_text_alignment primary_alignment,
        ntg_alignment secondary_alignment, ntg_label_content* out_content);

/* -------------------------------------------------------------------------- */

struct ntg_label_opts ntg_label_opts_default()
{
    return (struct ntg_label_opts) {
        .orientation = NTG_ORIENTATION_HORIZONTAL,
        .primary_alignment = NTG_TEXT_ALIGNMENT_1,
        .secondary_alignment = NTG_ALIGNMENT_1,
        .indent = 0,
        .wrap_mode = NTG_TEXT_WRAP_NOWRAP
    };
}

static void __init_default_values(ntg_label* label)
{
    label->_text = (struct ntg_str) {0};
    label->_gfx = NT_GFX_DEFAULT;
    label->_opts = ntg_label_opts_default();
}

void __ntg_label_init__(ntg_label* label, ntg_orientation orientation)
{
    assert(label != NULL);

    __ntg_object_init__(NTG_OBJECT(label),
            NTG_OBJECT_WIDGET,
            _ntg_label_measure_fn,
            NULL, NULL,
            _ntg_label_arrange_drawing_fn);

    __init_default_values(label);

    label->_opts.orientation = orientation;
}

void __ntg_label_deinit__(ntg_label* label)
{
    assert(label != NULL);

    __ntg_object_deinit__(NTG_OBJECT(label));

    if(label->_text.data != NULL)
        free(label->_text.data);

    __init_default_values(label);
}

void ntg_label_set_text(ntg_label* label, struct ntg_str_view text)
{
    char* new_text_data = (char*)realloc(label->_text.data, text.len + 1);
    assert(new_text_data != NULL);

    memcpy(new_text_data, text.data, text.len);

    label->_text.data = new_text_data;
    label->_text.len = text.len;
}

void ntg_label_set_gfx(ntg_label* label, struct nt_gfx gfx)
{
    assert(label != NULL);

    label->_gfx = gfx;
}

void ntg_label_set_opts(ntg_label* label, struct ntg_label_opts opts)
{
    assert(label != NULL);

    label->_opts = opts;
}

static size_t __wrap_rows_for_row(size_t row_count, size_t for_size)
{
    return ceil((1.0 * (row_count)) / for_size);
}

static size_t __wwrap_rows_for_row(const struct ntg_str_utf32_view row,
        size_t indent, size_t for_size)
{
    struct ntg_str_utf32_split_result words = ntg_str_utf32_split(row, ' ');

    size_t i;
    size_t it_word_len = 0;
    size_t rows_needed = 0;
    size_t curr_row_len = 0;
    size_t effective_space, effective_indent;
    for(i = 0; i < words.count; i++)
    {
        it_word_len = words.views[i].count;
        effective_space = (curr_row_len > 0) ? 1 : 0;
        effective_indent = (rows_needed == 0) ? indent : 0;
        if((curr_row_len + effective_space + it_word_len) <= (for_size - effective_indent))
        {
            curr_row_len += (effective_space + it_word_len);
            if(i == (words.count - 1))
            {
                rows_needed++;
                break;
            }
        }
        else // not enough space
        {
            if(it_word_len <= for_size) // can fit in next row
            {
                rows_needed++;
                curr_row_len = it_word_len;
            }
            else // can't fit at all
            {
                rows_needed += 2;
                curr_row_len = 0;
            }
        }
    }

    return rows_needed;
}

struct ntg_measure_result _ntg_label_measure_fn(const ntg_object* _label,
        ntg_orientation orientation, size_t for_size,
        const ntg_measure_context* context)
{
    assert(_label != NULL);
    ntg_label* label = NTG_LABEL(_label);

    if(label->_text.data == NULL) return (struct ntg_measure_result) {0};
    size_t len = label->_text.len;
    if(len == 0) return (struct ntg_measure_result) {0};

    struct ntg_str_view _text = {
        .data = label->_text.data,
        .len = label->_text.len
    };
    struct ntg_str_split_result split_res = ntg_str_split(_text, '\n');
    if(split_res.views == NULL) assert(0);
    ntg_label_rows_utf32 rows; // rows converted to utf32
    __ntg_label_rows_utf32_init__(&rows, split_res.views, split_res.count);
    free(split_res.views);

    /* primary size */
    size_t max_row_len = 0;
    size_t it_adj_row_len;
    size_t max_word_size = 0;

    /* secondary size */
    size_t wrap_sum = 0;
    size_t wwrap_sum = 0;

    size_t empty_rows = 0;

    size_t i;
    struct ntg_str_utf32_view it_row;
    for(i = 0; i < rows._count; i++)
    {
        it_row = (struct ntg_str_utf32_view) {
            .data = rows._data[i].data,
            .count = rows._data[i].count
        };
        it_adj_row_len = it_row.count + label->_opts.indent;

        max_row_len = _max2_size(max_row_len, it_adj_row_len);

        wrap_sum += __wrap_rows_for_row(it_adj_row_len, for_size);

        wwrap_sum += __wwrap_rows_for_row(rows._data[i], label->_opts.indent, for_size);

        if(rows._data[i].count == 0) empty_rows++;
    }

    if(orientation == label->_opts.orientation)
    {
        switch(label->_opts.wrap_mode)
        {
            case NTG_TEXT_WRAP_NOWRAP:
                return (struct ntg_measure_result) {
                    .min_size = max_row_len,
                    .natural_size = max_row_len,
                    .max_size = max_row_len
                };
            case NTG_TEXT_WRAP_WRAP:
                return (struct ntg_measure_result) {
                    .min_size = 1,
                    .natural_size = max_row_len,
                    .max_size = max_row_len
                };
            case NTG_TEXT_WRAP_WORD_WRAP:
                return (struct ntg_measure_result) {
                    .min_size = max_word_size,
                    .natural_size = max_row_len,
                    .max_size = max_row_len
                };
        }
    }
    else
    {
        switch(label->_opts.wrap_mode)
        {
            case NTG_TEXT_WRAP_NOWRAP:
                return (struct ntg_measure_result) {
                    .min_size = rows._count,
                    .natural_size = rows._count,
                    .max_size = rows._count
                };
            case NTG_TEXT_WRAP_WRAP:
                return (struct ntg_measure_result) {
                    .min_size = wrap_sum + empty_rows,
                    .natural_size = wrap_sum + empty_rows,
                    .max_size = wrap_sum + empty_rows
                };
            case NTG_TEXT_WRAP_WORD_WRAP:
                return (struct ntg_measure_result) {
                    .min_size = wwrap_sum + empty_rows,
                    .natural_size = wwrap_sum + empty_rows,
                    .max_size = wwrap_sum + empty_rows
                };
        }
    }

    __ntg_label_rows_utf32_deinit__(&rows);
}

void _ntg_label_arrange_drawing_fn(const ntg_object* _label,
        struct ntg_xy size, ntg_object_drawing* out_drawing)
{
    assert(_label != NULL);
    ntg_label* label = NTG_LABEL(_label);

    if(label->_text.data == NULL) return;

    struct ntg_str_view view = { 
        .data = label->_text.data,
        .len = label->_text.len
    };
    struct ntg_str_split_result split_res = ntg_str_split(view, '\n');
    if(split_res.views == NULL) assert(0);
    ntg_label_rows_utf32 rows; // rows converted to utf32
    __ntg_label_rows_utf32_init__(&rows, split_res.views, split_res.count);
    free(split_res.views);

    struct ntg_xy arrange_size = 
        (label->_opts.orientation == NTG_ORIENTATION_HORIZONTAL) ?
        size : ntg_xy_transpose(size);

    ntg_label_content _content; // content matrix
    __ntg_label_content_init__(&_content, arrange_size);

    switch(label->_opts.wrap_mode)
    {
        case NTG_TEXT_WRAP_NOWRAP:
            __arrange_label_content_nowrap(&rows, label->_opts.indent,
                    label->_opts.primary_alignment,
                    label->_opts.secondary_alignment,
                    &_content);
            break;
        case NTG_TEXT_WRAP_WRAP:
            assert(0);
            // result = __arrange_drawing_wrap();
            break;
        case NTG_TEXT_WRAP_WORD_WRAP:
            assert(0);
            // result = __arrange_drawing_word_wrap();
            break;
        default: assert(0);
    }

    size_t i, j;
    ntg_cell* it_cell;
    uint32_t* it_char;
    struct ntg_xy it_xy, it_content_xy;
    for(i = 0; i < size.y; i++)
    {
        for(j = 0; j < size.x; j++)
        {
            it_xy = ntg_xy(j, i);
            it_content_xy = 
            (label->_opts.orientation == NTG_ORIENTATION_HORIZONTAL) ?
            it_xy : ntg_xy_transpose(it_xy);

            it_cell = ntg_object_drawing_at_(out_drawing, it_xy);
            it_char = ntg_label_content_at(&_content, it_content_xy);

            (*it_cell) = ntg_cell_full((*it_char), label->_gfx);
        }
    }

    __ntg_label_rows_utf32_deinit__(&rows);
    __ntg_label_content_deinit__(&_content);
}

/* -------------------------------------------------------------------------- */

static void __row_apply_alignment_and_indent(uint32_t* row, size_t indent,
        size_t content_len, size_t row_total_len, ntg_text_alignment alignment)
{
    assert(row != NULL);
    indent = _min2_size(indent, row_total_len);
    content_len = _min2_size(content_len, row_total_len);
    assert(content_len <= row_total_len);

    if(alignment == NTG_TEXT_ALIGNMENT_JUSTIFY)
    {
        assert(0);
    }
    else
    {
        size_t total_indent;
        switch(alignment)
        {
            case NTG_TEXT_ALIGNMENT_1:
                total_indent = indent;
                break;
            case NTG_TEXT_ALIGNMENT_2:
                total_indent = _max2_size((row_total_len - content_len) / 2, indent);
                break;
            case NTG_TEXT_ALIGNMENT_3:
                total_indent = _max2_size(row_total_len - content_len, indent);
                break;
            default: assert(0);
        }
        size_t adj_content_len = (content_len + total_indent) <= row_total_len ?
            content_len : row_total_len - total_indent;

        memmove(row + total_indent,
                row,
                sizeof(uint32_t) * adj_content_len);

        size_t i;
        for(i = 0; i < total_indent; i++)
            row[i] = NTG_CELL_EMPTY;

        for(i = total_indent + adj_content_len; i < row_total_len; i++)
            row[i] = NTG_CELL_EMPTY;
    }
}

/* Ignores orientation */
static void __arrange_label_content_nowrap(const ntg_label_rows_utf32* rows,
        size_t indent, ntg_text_alignment primary_alignment,
        ntg_alignment secondary_alignment, ntg_label_content* out_content)
{
    size_t first_row_offset;
    if(secondary_alignment == NTG_ALIGNMENT_1)
        first_row_offset = 0;
    else if(secondary_alignment == NTG_ALIGNMENT_2)
        first_row_offset = (out_content->_size.y >= rows->_count) ?
            (out_content->_size.y - rows->_count) / 2 :
            0;
    else // NTG_ALIGNMENT_3
        first_row_offset = (out_content->_size.y >= rows->_count) ?
            (out_content->_size.y - rows->_count) :
            0;

    size_t i, j;
    struct ntg_xy it_xy;
    uint32_t *it_char;
    struct ntg_str_utf32* it_row;
    uint32_t* it_content_row;
    for(i = 0; i < rows->_count; i++)
    {
        if(i >= out_content->_size.y) break;
        it_row = &(rows->_data[i]);

        for(j = 0; j < it_row->count; j++)
        {
            if(j >= out_content->_size.x) break;

            it_xy = ntg_xy(j, i + first_row_offset);

            it_char = ntg_label_content_at(out_content, it_xy);
            (*it_char) = it_row->data[j];
        }

        it_content_row = ntg_label_content_at(out_content, ntg_xy(0, i + first_row_offset));
        __row_apply_alignment_and_indent(it_content_row, indent, j,
                out_content->_size.x, primary_alignment);
    }
}
